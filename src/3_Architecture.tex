\chapter{CƠ SỞ LÝ THUYẾT}
\section{Tổng quan về ESP32-S3-Touch-LCD-7}
\tab ESP32-S3-Touch-LCD-7 là một nền tảng phát triển mạnh mẽ, kết hợp giữa khả năng tính toán cao cấp của vi điều khiển ESP32-S3 và trải nghiệm giao diện người dùng vượt trội với màn hình cảm ứng điện dung 7 inch. Được thiết kế và phát triển bởi Waveshare, thiết bị này hướng tới các ứng dụng yêu cầu sự giao tiếp trực quan, khả năng xử lý dữ liệu nhanh chóng và tính linh hoạt cao trong môi trường IoT và công nghiệp.

\tab Sự hội tụ giữa công nghệ hiển thị IPS tiên tiến, khả năng cảm ứng đa điểm nhạy bén, cùng với khả năng kết nối mạng không dây Wi-Fi/Bluetooth 5.0, đã biến ESP32-S3-Touch-LCD-7 trở thành lựa chọn lý tưởng cho các dự án giao diện người máy (HMI), hệ thống điều khiển tự động, các thiết bị điện tử tiêu dùng cao cấp và những giải pháp IoT cần tính năng tương tác trực quan.

\begin{figure}[H] 
  \centering 
  \includegraphics[width=0.8\textwidth]{Images/ESP32-S3-Touch-LCD-7-details-1.jpg} 
  \caption{ESP32-S3-Touch-LCD-7 (Giao diện mặt trước)} 
\end{figure}

\subsection{Cấu hình phần cứng tổng quan}
\tab Trung tâm của mô-đun ESP32-S3-Touch-LCD-7 là bộ vi điều khiển ESP32-S3R8, một phiên bản mạnh mẽ thuộc dòng ESP32-S3 với các tính năng chuyên biệt dành cho AI và xử lý đồ họa. Cấu trúc vi xử lý bao gồm:
\begin{itemize} 
  \item \textbf{CPU:} 2 nhân Xtensa LX7 tốc độ tối đa 240MHz, hỗ trợ tập lệnh SIMD tăng tốc xử lý song song. 
  \item \textbf{RAM nội:} 512KB SRAM + 8MB PSRAM ngoài, đảm bảo khả năng lưu trữ bộ đệm lớn cho các tác vụ đồ họa nặng. 
  \item \textbf{Flash:} 16MB Flash SPI tốc độ cao, đáp ứng nhu cầu lưu trữ chương trình và dữ liệu lớn. 
  \item \textbf{Màn hình:} IPS LCD 7.0 inch, độ phân giải 1024x600 pixel, hiển thị màu sắc sống động với góc nhìn rộng lên tới 170 độ. 
  \item \textbf{Cảm ứng điện dung:} Hỗ trợ đa điểm, sử dụng chip điều khiển cảm ứng GT911, đem lại trải nghiệm chạm, vuốt mượt mà. 
\end{itemize}
\tab Ngoài ra, mô-đun còn được tích hợp các phần tử giao tiếp ngoại vi mạnh mẽ như USB Type-C hỗ trợ chức năng OTG, cổng mở rộng GPIO đầy đủ chức năng (SPI, I2C, UART, ADC, PWM, SDIO), khe cắm thẻ nhớ microSD và giao tiếp Camera (DVP), mang lại khả năng mở rộng tối đa cho các dự án đa dạng.
\subsection{Khả năng kết nối không dây và bảo mật}
\tab ESP32-S3-Touch-LCD-7 kế thừa đầy đủ sức mạnh kết nối không dây từ vi điều khiển ESP32-S3:

\begin{itemize} 
  \item \textbf{Wi-Fi 2.4GHz (802.11 b/g/n):} Cho phép mô-đun giao tiếp mạng LAN, Internet hoặc tạo mạng nội bộ (SoftAP) để kết nối các thiết bị khác. 
  \item \textbf{Bluetooth 5.0 LE:} Hỗ trợ BLE Mesh, Extended Advertising giúp mở rộng phạm vi và tăng hiệu quả truyền dữ liệu. 
\end{itemize}

\tab Bên cạnh đó, hệ thống còn được tích hợp nhiều cơ chế bảo mật phần cứng như:

\textbf{Secure Boot:} Bảo vệ quá trình khởi động khỏi firmware trái phép.

\textbf{Flash Encryption:} Mã hóa nội dung bộ nhớ flash, đảm bảo dữ liệu và chương trình an toàn trước tấn công vật lý.

\textbf{Bộ tăng tốc phần cứng:} Hỗ trợ các thuật toán mã hóa AES, SHA-2, RSA, ECC phục vụ các ứng dụng bảo mật cao cấp.

\subsection{Khả năng hiển thị đồ họa và tương tác cảm ứng}
\tab Điểm nhấn ấn tượng nhất của ESP32-S3-Touch-LCD-7 nằm ở khả năng hiển thị đồ họa sắc nét kết hợp với cảm ứng điện dung hiện đại. Sử dụng giao tiếp Parallel RGB tốc độ cao giữa vi xử lý và màn hình, thiết bị đảm bảo tốc độ làm tươi hình ảnh nhanh chóng, mang lại trải nghiệm hình ảnh mượt mà, không giật lag.

\tab Màn hình IPS LCD 7 inch không chỉ mang lại độ phân giải cao (1024x600 pixel) mà còn có độ sáng lớn và độ tương phản cao, giúp hiển thị tốt ngay cả trong môi trường ánh sáng mạnh.

\tab Cảm biến cảm ứng điện dung hỗ trợ đa điểm, cho phép thực hiện các thao tác chạm, kéo, vuốt, phóng to/thu nhỏ (multi-touch gestures) mượt mà, đáp ứng yêu cầu giao diện người dùng thân thiện và hiện đại.


\subsection{Môi trường phát triển phần mềm}
\tab Để hỗ trợ lập trình và phát triển phần mềm, ESP32-S3-Touch-LCD-7 tương thích với nhiều công cụ đa dạng, cho phép lập trình viên lựa chọn theo nhu cầu:

\begin{itemize} 
  \item \textbf{ESP-IDF:} Bộ công cụ chính thức từ Espressif, hỗ trợ đầy đủ FreeRTOS, LVGL, giao thức mạng MQTT, HTTP, mDNS, OTA update, bảo mật TLS. 
  \item \textbf{Arduino IDE:} Dễ sử dụng cho những người mới làm quen với ESP32, với thư viện hỗ trợ màn hình cảm ứng và kết nối mạng phong phú. 
  \item \textbf{LVGL (Light and Versatile Graphics Library):} Thư viện đồ họa mã nguồn mở mạnh mẽ, tối ưu hóa cho ESP32-S3, hỗ trợ tạo giao diện người dùng đẹp mắt, chuyên nghiệp. 
  \item \textbf{MicroPython:} Hỗ trợ lập trình nhanh gọn bằng ngôn ngữ Python. 
\end{itemize}

\tab Ngoài ra, thiết bị còn hỗ trợ các công cụ debug tiên tiến như OpenOCD, GDB Debugger, và ESP-Prog để hỗ trợ phân tích lỗi và tối ưu chương trình.

\subsection{Ứng dụng thực tế}
\tab Nhờ sự kết hợp hài hòa giữa phần cứng mạnh mẽ, giao diện người dùng hiện đại và khả năng kết nối linh hoạt, ESP32-S3-Touch-LCD-7 có thể được ứng dụng trong rất nhiều lĩnh vực:

\begin{itemize} 
  \item \textbf{Thiết bị nhà thông minh:} Bảng điều khiển trung tâm cho hệ thống ánh sáng, điều hòa, an ninh. 
  \item \textbf{HMI công nghiệp:} Giao diện điều khiển máy móc, giám sát trạng thái sản xuất theo thời gian thực. 
  \item \textbf{Thiết bị chăm sóc sức khỏe:} Máy đo chỉ số sức khỏe, thiết bị y tế cá nhân thông minh. 
  \item \textbf{Bảng điều khiển ô tô điện/xe máy điện:} Hiển thị tốc độ, quãng đường, trạng thái pin. 
  \item \textbf{Các sản phẩm tiêu dùng cao cấp:} Bếp thông minh, hệ thống POS, máy bán hàng tự động. 
\end{itemize}
\section{Ngôn ngữ lập trình C/C++}

\subsection{Vai trò cốt lõi của C/C++ trong hệ thống nhúng}
Ngôn ngữ C từ lâu đã trở thành tiêu chuẩn vàng trong phát triển hệ thống nhúng nhờ khả năng kiểm soát phần cứng sát cấp thấp, hiệu suất thực thi cao và khả năng biên dịch đa nền tảng. Các đặc điểm nổi bật như quản lý bộ nhớ thủ công, cú pháp đơn giản và khả năng tương thích rộng với trình biên dịch giúp C trở thành lựa chọn hàng đầu trên các nền tảng MCU như ARM Cortex-M, AVR, RISC-V và ESP32.

C++ bổ sung các tính năng mạnh mẽ của lập trình hướng đối tượng (OOP) như kế thừa, đa hình (polymorphism), trừu tượng hóa (abstraction) và đóng gói (encapsulation), cho phép cấu trúc mã nguồn rõ ràng, dễ mở rộng – đặc biệt hữu ích trong các dự án GUI có nhiều lớp giao diện, trạng thái và đối tượng tương tác.

\textbf{Ví dụ:} Trong một ứng dụng điều khiển thông minh, ta có thể định nghĩa một lớp cơ sở \texttt{Screen} với các phương thức ảo như \texttt{onLoad()}, \texttt{onExit()} và kế thừa cho các lớp cụ thể như \texttt{MainScreen}, \texttt{SettingsScreen}, giúp tách biệt giao diện và logic điều khiển.

\subsection{Lý do chọn ngôn ngữ C/C++ cho phát triển giao diện với LVGL}

\subsubsection{LVGL được viết thuần bằng C}
LVGL là một thư viện đồ họa mã nguồn mở được thiết kế cho vi điều khiển. Đặc điểm then chốt là nó được viết hoàn toàn bằng C thuần, không có bất kỳ \textit{dependency} nào vào hệ điều hành hoặc thư viện ngoài, giúp:
\begin{itemize}
  \item Dễ dàng \textit{port} lên bất kỳ nền tảng phần cứng nào.
  \item Tương thích hoàn toàn với ESP-IDF (framework chính thức của ESP32).
  \item Tránh \textit{overhead} không cần thiết, rất quan trọng trong các hệ thống thời gian thực (RTOS).
\end{itemize}

Việc phát triển ứng dụng sử dụng LVGL bằng ngôn ngữ C giúp lập trình viên có thể sử dụng trực tiếp các API như \texttt{lv\_btn\_create()}, \texttt{lv\_label\_set\_text()} mà không cần tạo lớp trừu tượng hoặc \textit{wrapper}, đảm bảo hiệu suất tối ưu và độ ổn định cao.

\subsubsection{Quản lý bộ nhớ tối ưu}
ESP32 có lượng RAM giới hạn (320KB SRAM, có thể thêm PSRAM ngoài), do đó việc kiểm soát bộ nhớ là sống còn. Ngôn ngữ C hỗ trợ ba dạng quản lý bộ nhớ:
\begin{itemize}
  \item \textbf{Bộ nhớ tĩnh (static memory)}: sử dụng khi kích thước bộ nhớ đã biết tại thời điểm biên dịch.
  \item \textbf{Bộ nhớ tự động (stack memory)}: dùng cho biến cục bộ, giải phóng khi hàm thoát.
  \item \textbf{Bộ nhớ động (heap memory)}: cấp phát tại \textit{runtime} với \texttt{malloc()} và giải phóng với \texttt{free()}.
\end{itemize}

Trong môi trường ESP-IDF, các hàm như \texttt{heap\_caps\_malloc()} cho phép chỉ định vùng bộ nhớ phù hợp: DRAM, PSRAM, DMA-capable... giúp tối ưu hóa hiệu suất và tránh \textit{fragmentation}.

\subsubsection{C++ hỗ trợ tổ chức GUI theo mô hình hướng đối tượng}
Trong dự án GUI với LVGL, việc sử dụng OOP giúp giảm độ phức tạp và nâng cao tính bảo trì:
\begin{itemize}
  \item \textbf{Kế thừa}: các màn hình GUI kế thừa từ một lớp cha có sẵn logic khởi tạo chung.
  \item \textbf{Đa hình}: mỗi màn hình có thể định nghĩa cách hiển thị, xử lý sự kiện khác nhau mà vẫn dùng cùng một \textit{interface}.
  \item \textbf{Tái sử dụng mã}: các \textit{widget} hoặc thành phần như \texttt{MessageBox}, \texttt{SliderPanel}, \texttt{LoadingOverlay} có thể được viết thành \texttt{class} và sử dụng lại ở nhiều nơi.
\end{itemize}

\subsection{Ưu điểm chi tiết}

\begin{table}[H]
\centering
\begin{tabular}{|p{4.5cm}|p{10cm}|}
\hline
\textbf{Đặc điểm} & \textbf{Mô tả chuyên sâu} \\
\hline
Tốc độ thực thi nhanh & C/C++ được biên dịch trực tiếp thành mã máy, không thông qua VM hay runtime, giúp giảm độ trễ xử lý – đặc biệt quan trọng trong GUI real-time (animation, touch response). \\
\hline
Tối ưu bộ nhớ & Lập trình viên có thể tinh chỉnh từng byte bộ nhớ sử dụng, giảm nguy cơ out-of-memory hoặc crash runtime. \\
\hline
Mô-đun hóa tốt với C++ & Việc chia mã nguồn thành các module (class) giúp dễ bảo trì, tách biệt giao diện với logic, giảm lỗi phát sinh khi mở rộng hệ thống. \\
\hline
Hỗ trợ toolchain mạnh mẽ & Các công cụ như \texttt{idf.py}, \texttt{esp\_log}, \texttt{heap\_trace}, \texttt{perftest}, \texttt{OpenOCD} giúp giám sát chi tiết RAM, thời gian xử lý và hiệu suất toàn hệ thống. \\
\hline
Khả năng mở rộng & Có thể kết hợp với các thư viện xử lý logic khác như \texttt{protobuf}, \texttt{tinyxml}, \texttt{json-c} hoặc dùng C++ template để viết các class generic. \\
\hline
\end{tabular}
\end{table}

\subsection{Hạn chế và biện pháp khắc phục}

\begin{table}[H]
\centering
\begin{tabular}{|p{6cm}|p{8.5cm}|}
\hline
\textbf{Hạn chế} & \textbf{Giải pháp kỹ thuật} \\
\hline
Quản lý bộ nhớ thủ công dễ gây \textit{leak} & Sử dụng RAII (Resource Acquisition Is Initialization) trong C++, kết hợp smart pointers nếu áp dụng được. \\
\hline
Runtime error khó phát hiện & Dùng \texttt{esp\_log}, kiểm tra \texttt{null-pointer}, xác thực cấp phát trước khi sử dụng; bật tính năng heap poisoning hoặc heap tracing trong \texttt{menuconfig}. \\
\hline
Không có bảo vệ biên tự động & Viết \textit{wrapper} kiểm tra \textit{bound array}, dùng \texttt{assert} trong quá trình phát triển. \\
\hline
C++ có thể làm phình mã nhị phân & Tránh dùng các thành phần STL nặng như \texttt{<vector>}, \texttt{<map>}; thay bằng \texttt{struct}/\texttt{array} thủ công hoặc các thư viện nhẹ như \texttt{etl (Embedded Template Library)}. \\
\hline
\end{tabular}
\end{table}

\subsection{Ứng dụng thực tế trong hệ thống dùng LVGL trên ESP32}

\begin{table}[H]
\centering
\begin{tabular}{|p{5cm}|p{3cm}|p{6.5cm}|}
\hline
\textbf{Tầng hệ thống} & \textbf{Ngôn ngữ đề xuất} & \textbf{Giải thích} \\
\hline
Driver phần cứng (LCD, touch, backlight) & C & Tận dụng ESP-IDF driver: \texttt{esp\_lcd\_panel\_io\_spi}, \texttt{esp\_lcd\_touch}, dễ tối ưu, chạy được trong \textit{interrupt context}. \\
\hline
Core xử lý GUI & C/C++ & C để dùng API LVGL, C++ để xây dựng các màn hình logic theo hướng object. \\
\hline
Giao tiếp ngoại vi (WiFi, BLE, MQTT) & C & Các \textit{stack} WiFi/Bluetooth/MQTT trong ESP-IDF đều là C thuần. \\
\hline
Quản lý trạng thái màn hình, hoạt cảnh & C++ & FSM, State Pattern dễ viết bằng class, hỗ trợ constructor/destructor rõ ràng. \\
\hline
Hệ thống sự kiện (Event Queue) & C++ & Có thể dùng template hoặc EventBus theo kiểu Observer Pattern. \\
\hline
\end{tabular}
\end{table}
\section{Cơ sở lý thuyết về module RS485}
\subsection{Giới thiệu chung về module RS485} 
\tab Module RS485 là một thiết bị trung gian giúp chuyển đổi tín hiệu UART (TTL) từ vi điều khiển sang chuẩn truyền thông RS485, cho phép giao tiếp trong các hệ thống truyền dữ liệu công nghiệp hoặc khoảng cách xa. Các module này thường được tích hợp sẵn mạch điện trở kéo, bảo vệ điện áp và mạch truyền nhận để đảm bảo tín hiệu ổn định và an toàn trong quá trình truyền thông.\\
\tab RS485 hỗ trợ giao tiếp đa điểm (multi-point), cho phép kết nối nhiều thiết bị với nhau trên cùng một đường truyền dữ liệu (bus), giúp đơn giản hóa hệ thống dây và giảm chi phí triển khai trong các ứng dụng như hệ thống giám sát, tự động hóa tòa nhà, mạng cảm biến môi trường, v.v.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{Images/RS485.png}
  \caption{RS485 module}
\end{figure}
\subsection{Nguyên lý hoạt động của module RS485} 
\tab Module RS485 hoạt động dựa trên nguyên lý truyền vi sai (differential signaling), sử dụng hai dây tín hiệu chính là A và B. Tín hiệu được truyền dưới dạng chênh lệch điện áp giữa hai dây này thay vì so với mass như các chuẩn UART hay RS232 thông thường. Khi mức điện áp trên chân A cao hơn B (A > B), tín hiệu được xem là logic "1", ngược lại nếu A < B thì là logic "0". Điều này giúp loại bỏ nhiễu điện từ chung trên đường truyền và duy trì tính toàn vẹn dữ liệu.\\
\tab Các module RS485 phổ biến hiện nay sử dụng IC chuyển đổi như MAX485, SP485, hoặc SN75176 để thực hiện quá trình mã hóa và giải mã tín hiệu vi sai. Các IC này thường hỗ trợ cả chế độ truyền và nhận (half-duplex), và cần thêm một chân điều khiển (thường là DE/RE) để chuyển đổi giữa hai chế độ.

\subsection{Kết nối với vi điều khiển (ví dụ ESP32-S3)} 
\tab Việc kết nối module RS485 với vi điều khiển như ESP32-S3 thường thông qua giao tiếp UART. Các chân TX và RX của vi điều khiển được nối với module RS485 thông qua mạch chuyển đổi mức tín hiệu. Ngoài ra, chân DE (Driver Enable) và RE (Receiver Enable) thường được điều khiển bằng phần mềm để bật chế độ truyền hoặc nhận dữ liệu. Trong nhiều module, DE và RE được nối với nhau và điều khiển chung qua một chân GPIO của vi điều khiển để đơn giản hóa việc lập trình.\\
\tab Ví dụ, để gửi dữ liệu, chân DE/RE được đặt ở mức HIGH để bật chế độ truyền. Sau khi gửi xong, chân này sẽ được kéo xuống mức LOW để chuyển sang chế độ nhận. Thời điểm chuyển trạng thái cần được lập trình chính xác để tránh mất dữ liệu hoặc xung đột đường truyền.

\subsection{Ứng dụng thực tế} 
\tab Module RS485 được sử dụng rộng rãi trong nhiều ứng dụng yêu cầu truyền thông ổn định ở khoảng cách xa như: 
\begin{itemize} 
  \item Giao tiếp giữa các bộ điều khiển khả trình (PLC) và cảm biến/thiết bị chấp hành. 
  \item Mạng Modbus RTU trong hệ thống SCADA. 
  \item Mạng cảm biến trong nhà máy, nông nghiệp thông minh, hoặc giám sát năng lượng. 
  \item Hệ thống đo đạc từ xa như đồng hồ điện, nước, và hệ thống kiểm soát truy cập. 
\end{itemize} 
\tab Với khả năng chống nhiễu tốt, chi phí thấp và triển khai dễ dàng, module RS485 là lựa chọn lý tưởng cho các hệ thống truyền thông công nghiệp và IoT.

\section{MQTT trong IoT}

\subsection{Tổng quan về MQTT}

MQTT (Message Queuing Telemetry Transport) là một giao thức truyền thông nhẹ, được thiết kế tối ưu cho các ứng dụng có băng thông thấp, độ trễ cao hoặc yêu cầu tiêu thụ năng lượng thấp — đặc điểm điển hình trong các hệ thống Internet of Things (IoT). Giao thức này hoạt động theo mô hình \textbf{publish/subscribe} (xuất bản/đăng ký), cho phép các thiết bị trao đổi dữ liệu thông qua một máy chủ trung gian gọi là \textbf{broker}.

MQTT ban đầu được phát triển bởi IBM vào năm 1999 và hiện nay là một chuẩn mở, được quản lý bởi tổ chức OASIS (Organization for the Advancement of Structured Information Standards).
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{Images/MQTT-trong-IoT.png}
  \caption{MQTT trong IoT}
\end{figure}
\subsection{Kiến trúc MQTT}

Kiến trúc MQTT bao gồm ba thành phần chính:

\begin{itemize}
    \item \textbf{Publisher (Thiết bị xuất bản):} Gửi thông điệp đến một chủ đề (topic) cụ thể.
    \item \textbf{Subscriber (Thiết bị đăng ký):} Nhận thông điệp bằng cách đăng ký các chủ đề quan tâm.
    \item \textbf{Broker (Máy chủ trung gian):} Tiếp nhận các thông điệp từ publisher và phân phối chúng đến các subscriber phù hợp. Ví dụ broker phổ biến: Mosquitto, HiveMQ, EMQX.
\end{itemize}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{Images/mo-hinh-mqtt.png}
  \caption{Mô hình Publish/Subscriber trong giao thức MQTT}
\end{figure}
\subsection{Nguyên lý hoạt động}

Khi một thiết bị \textbf{publisher} gửi một thông điệp (message) đến một \textbf{topic}, \textbf{broker} sẽ tiếp nhận thông điệp và phân phối nó đến tất cả các thiết bị \textbf{subscriber} đã đăng ký với topic đó. Giao thức MQTT cho phép hệ thống mở rộng dễ dàng và giảm đáng kể độ phụ thuộc giữa các thiết bị đầu cuối.

Ví dụ:
\begin{itemize}
    \item Publisher gửi dữ liệu cảm biến đến topic \texttt{``/home/temperature''}.
    \item Tất cả các subscriber quan tâm đến chủ đề này sẽ nhận được dữ liệu mà không cần biết thông tin về publisher.
\end{itemize}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{Images/mqtt-data-1.png}
  \caption{Cơ chế hoạt động của giao thức MQTT}
\end{figure}
\subsection{Cấu trúc topic}

Topic trong MQTT được tổ chức theo dạng cây, sử dụng dấu gạch chéo \texttt{/} để phân tách các cấp.

Ví dụ:
\begin{itemize}
    \item \texttt{/home/livingroom/temperature}
    \item \texttt{/device/esp32/status}
\end{itemize}

MQTT hỗ trợ ký tự đại diện:
\begin{itemize}
    \item \texttt{+} đại diện cho một cấp (level).
    \item \texttt{\#} đại diện cho nhiều cấp (từ vị trí hiện tại trở đi).
\end{itemize}

\subsection{Chất lượng dịch vụ (QoS)}

MQTT hỗ trợ ba mức độ đảm bảo chất lượng dịch vụ (Quality of Service - QoS):

\begin{itemize}
    \item \textbf{QoS 0 - At most once:} Gửi một lần và không đảm bảo nhận được.
    \item \textbf{QoS 1 - At least once:} Gửi ít nhất một lần, có thể trùng lặp.
    \item \textbf{QoS 2 - Exactly once:} Gửi đúng một lần (đảm bảo không trùng và không mất).
\end{itemize}

\subsection{Ứng dụng của MQTT trong IoT}

MQTT được sử dụng rộng rãi trong nhiều hệ thống IoT nhờ vào tính nhẹ, đơn giản và hiệu quả:

\begin{itemize}
    \item \textbf{Nhà thông minh (Smart home):} Kết nối thiết bị đèn, cảm biến, điều hòa.
    \item \textbf{Nông nghiệp thông minh:} Gửi dữ liệu độ ẩm, nhiệt độ, mực nước về máy chủ.
    \item \textbf{Giám sát công nghiệp:} Truyền dữ liệu cảm biến từ xa về trung tâm điều khiển.
    \item \textbf{Thiết bị đeo và sức khỏe:} Đồng bộ hóa dữ liệu sức khỏe với cloud server.
\end{itemize}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{Images/ung-dung-mqtt.png}
  \caption{Ứng dụng của MQTT trong IoT}
\end{figure}
\subsection{Ưu và nhược điểm của MQTT}
\textbf{Ưu điểm:}
\begin{itemize}
    \item Giao thức nhẹ, phù hợp với thiết bị tài nguyên hạn chế.
    \item Giao tiếp không đồng bộ và tách biệt giữa publisher và subscriber.
    \item Hỗ trợ nhiều mức QoS và cơ chế giữ kết nối (keep-alive).
\end{itemize}
\textbf{Nhược điểm:}
\begin{itemize}
    \item Phụ thuộc vào broker trung gian.
    \item Không mã hóa mặc định, cần kết hợp với SSL/TLS để đảm bảo an toàn.
    \item Không phù hợp với các ứng dụng yêu cầu thời gian thực chính xác tuyệt đối.
\end{itemize}
\section{Thư viện và Framework liên quan}
\subsection{ESP-IDF (Espressif IoT Development Framework)}
\subsubsection{Giới thiệu tổng quan về ESP-IDF}
ESP-IDF là framework chính thức do Espressif Systems phát triển nhằm hỗ trợ lập trình hệ thống cho các vi điều khiển dòng ESP32. Đây là một môi trường phát triển toàn diện, bao gồm hệ thống build, driver phần cứng, thư viện giao tiếp mạng, công cụ quản lý dự án, và hỗ trợ tích hợp nhiều công cụ debug, phân tích hiệu suất.\\
ESP-IDF được viết chủ yếu bằng ngôn ngữ C và hoạt động theo mô hình cấu trúc thấp tầng (low-level), cho phép người lập trình kiểm soát chi tiết các thành phần phần cứng, rất phù hợp trong các dự án nhúng chuyên nghiệp.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{Images/ESP-IDF.png}
  \caption{ESP-IDF}
\end{figure}
\subsubsection{Vai trò của ESP-IDF trong phát triển giao diện LVGL}
Trong bối cảnh ứng dụng LVGL trên ESP32, ESP-IDF đóng vai trò ``xương sống'' giúp kết nối giữa thư viện giao diện (LVGL) với phần cứng như màn hình LCD, bộ cảm ứng chạm, hoặc các giao tiếp ngoại vi (I2C, SPI). Ngoài ra, nó còn cung cấp:
\begin{itemize}
    \item Hệ điều hành thời gian thực FreeRTOS tích hợp sẵn, giúp xử lý song song các tác vụ: giao diện, WiFi, Bluetooth, sensor...
    \item ESP Timer giúp định kỳ gọi \texttt{lv\_timer\_handler()} --- hàm cốt lõi của LVGL để xử lý giao diện.
    \item ESP LCD: tập hợp các driver hiển thị LCD (SPI, RGB, I80), có thể liên kết dễ dàng với LVGL thông qua \texttt{disp\_flush\_cb()}.
    \item ESP LCD Touch: thư viện hỗ trợ cảm ứng điện dung hoặc điện trở (FT6x36, XPT2046, GT911, v.v.), liên kết với \texttt{indev\_read\_cb()} của LVGL.
\end{itemize}
\subsubsection{Các module và thành phần quan trọng trong ESP-IDF}
\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|l|l|X|}
  \hline
  \textbf{Thành phần} & \textbf{Vai trò chính} & \textbf{Liên quan đến LVGL} \\
  \hline
  esp\_lcd\_panel\_io\_spi & Giao tiếp SPI với LCD & Cần cấu hình chuẩn DMA, SPI tốc độ cao \\
  esp\_lcd\_touch & Giao tiếp với cảm ứng & Trả về tọa độ nhấn chạm cho LVGL \\
  esp\_timer & Hẹn giờ định kỳ & Gọi \texttt{lv\_timer\_handler()} với độ trễ cấu hình \\
  heap\_caps & Phân tích sử dụng RAM & Dùng để theo dõi leak RAM do \texttt{lv\_obj} gây ra \\
  esp\_log & Ghi log debug & Log lỗi, sự kiện UI, quản lý bộ nhớ \\
  freertos/task & Quản lý task, priority & Tạo task riêng cho GUI, ưu tiên cao hơn các tác vụ nền \\
  \hline
  \end{tabularx}
  \caption{Các thành phần ESP-IDF quan trọng liên quan đến LVGL}
  \end{table}
  
\subsubsection{Cách tích hợp LVGL vào ESP-IDF}
Tích hợp LVGL vào ESP-IDF yêu cầu thực hiện các bước cơ bản sau:
\begin{enumerate}
    \item Thêm thư viện LVGL vào project:
\begin{verbatim}
git submodule add https://github.com/lvgl/lvgl components/lvgl
\end{verbatim}
    \item Khai báo trong \texttt{CMakeLists.txt} hoặc \texttt{idf\_component.yml}.
    \item Cấu hình Timer và Display:
    \begin{itemize}
        \item Sử dụng \texttt{esp\_timer\_create()} để tạo timer định kỳ 5--10ms gọi \texttt{lv\_timer\_handler()}.
        \item Tạo driver LCD qua \texttt{esp\_lcd\_panel\_io\_spi\_new()} và \texttt{esp\_lcd\_panel\_new\_st7789()}.
    \end{itemize}
    \item Cấu hình Touch:
    \begin{itemize}
        \item Dùng \texttt{esp\_lcd\_touch\_new\_i2c()} để kết nối với driver cảm ứng.
        \item Tạo callback \texttt{indev\_read\_cb()} để LVGL nhận dữ liệu từ cảm ứng.
    \end{itemize}
\end{enumerate}

\subsubsection{Ưu điểm của ESP-IDF khi dùng với LVGL}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Ưu điểm} & \textbf{Mô tả chi tiết} \\
\hline
Tối ưu cho phần cứng ESP32 & Tương thích hoàn toàn với các peripheral của ESP32: SPI, DMA, RGB, Touch \\
Quản lý bộ nhớ tốt & Cung cấp heap tracker, log phân tích fragment \\
Hệ thống log mạnh & Phân luồng log theo TAG, độ ưu tiên \\
Cấu hình linh hoạt & Qua \texttt{menuconfig}, dễ cấu hình SPI clock, DMA, PSRAM \\
Tích hợp OTA, WiFi, BLE & Có thể phát triển GUI cho hệ thống kết nối IoT \\
\hline
\end{tabular}
\caption{Ưu điểm ESP-IDF khi tích hợp với LVGL}
\end{table}

\subsubsection{Nhược điểm và lưu ý khi sử dụng ESP-IDF}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{6cm}|p{6cm}|}
\hline
\textbf{Nhược điểm} & \textbf{Biện pháp khắc phục} \\
\hline
Cấu hình phức tạp cho người mới & Sử dụng template project, PlatformIO hỗ trợ \\
Dung lượng flash chiếm nhiều & Tối ưu \texttt{menuconfig}, tắt debug, loại bỏ unused component \\
Đòi hỏi hiểu rõ cấu trúc ESP-IDF & Tham khảo tài liệu chính thức, examples từ Espressif \\
Yêu cầu dùng CMake & Học cú pháp \texttt{CMakeLists.txt}, PlatformIO đã tự động hóa \\
\hline
\end{tabular}
\caption{Một số lưu ý khi dùng ESP-IDF}
\end{table}

% Arduino Framework
\subsection{Arduino Framework}

\subsubsection{Giới thiệu tổng quan về Arduino Framework}

Arduino là một nền tảng mã nguồn mở nổi tiếng, cung cấp một lớp trừu tượng cao hơn để lập trình vi điều khiển. Arduino framework đơn giản hóa việc phát triển nhúng bằng cách ẩn đi phần lớn cấu hình phần cứng phức tạp và cung cấp một tập hợp API thân thiện.\\
Trên ESP32, Arduino hoạt động như một lớp wrapper bên trên ESP-IDF, nghĩa là người dùng vẫn có thể truy cập các API ESP-IDF nếu cần, nhưng trong đa số trường hợp, họ chỉ cần dùng các hàm Arduino như \texttt{digitalWrite()}, \texttt{analogRead()}, \texttt{WiFi.begin()}, v.v.

\subsubsection{Lý do Arduino vẫn được lựa chọn khi phát triển giao diện với LVGL}
Dù không mạnh bằng ESP-IDF về khả năng kiểm soát thấp tầng, Arduino framework vẫn được nhiều nhà phát triển lựa chọn trong các trường hợp sau:
\begin{itemize}
    \item Phát triển nhanh prototype GUI nhờ cú pháp đơn giản và tài liệu dễ tra cứu.
    \item Đã có thư viện LVGL tích hợp sẵn: \texttt{lvgl\_Arduino}, \texttt{TFT\_eSPI + LVGL binding}.
    \item Thư viện cộng đồng mạnh: sensor, MQTT, Firebase...
\end{itemize}

\subsubsection{Kiến trúc Arduino trên ESP32}

\begin{table}[H]
  \centering
  \begin{tabularx}{\textwidth}{|X|X|X|}
  \hline
  \textbf{Thành phần} & \textbf{Vai trò} & \textbf{Ghi chú} \\
  \hline
  setup() và loop() & Hàm chính người dùng & Thay cho \texttt{main()} trong C truyền thống \\
  Arduino Core for ESP32 & Giao tiếp giữa API Arduino và ESP-IDF & Do Espressif phát triển \\
  SPI.h, Wire.h & Giao tiếp SPI/I2C đơn giản & Wrapper của ESP-IDF \\
  lvgl.h & API chính của GUI & Phải khởi tạo LVGL, buffer, flush... \\
  \hline
  \end{tabularx}
  \caption{Kiến trúc Arduino trên ESP32}
  \end{table}  

\subsubsection{Ưu điểm của Arduino Framework}
\begin{table}[H]
  \centering
  \begin{tabular}{|l|p{10cm}|}
  \hline
  \textbf{Ưu điểm} & \textbf{Giải thích chi tiết} \\
  \hline
  Cú pháp đơn giản & Dễ học, dễ dùng, phù hợp sinh viên và người mới tiếp cận nhúng \\
  Nhiều thư viện hỗ trợ & LVGL, TFT\_eSPI, Touch, WiFi, MQTT, WebServer có sẵn và hoạt động ổn định \\
  Tích hợp tốt với PlatformIO & Có thể dùng trên VS Code, dễ debug, tự động build/upload \\
  Giao diện lập trình cao cấp & Viết nhanh hơn, dễ tổ chức code nhờ class đơn giản và lambda callback \\
  Cộng đồng lớn & Dễ tìm ví dụ, diễn đàn hỗ trợ nhanh chóng \\
  \hline
  \end{tabular}
  \caption{Ưu điểm của Arduino framework}
\end{table}

\subsubsection{Hạn chế của Arduino khi dùng với LVGL}

\begin{table}[H]
\centering
\begin{tabular}{|l|p{5.5cm}|p{5.5cm}|}
\hline
\textbf{Hạn chế} & \textbf{Mô tả} & \textbf{Hướng khắc phục} \\
\hline
Thiếu kiểm soát sâu & Không can thiệp DMA, SPI nâng cao & Dùng API ESP-IDF trực tiếp \\
Không hỗ trợ menuconfig & Không tùy biến thông số hệ thống & Dùng build flags với PlatformIO \\
Hạn chế đa task & \texttt{loop()} là một task duy nhất & Dùng \texttt{xTaskCreate()} \\
Không tối ưu RAM & Không giám sát fragmentation & Dùng \texttt{heap\_caps\_get\_free\_size()} nếu có kinh nghiệm \\
\hline
\end{tabular}
\caption{Hạn chế của Arduino khi tích hợp với LVGL}
\end{table}

\subsubsection{Kịch bản sử dụng Arduino phù hợp}

\begin{itemize}
    \item Sinh viên, người mới bắt đầu học nhúng.
    \item Dự án nhỏ, thời gian gấp rút.
    \item Không cần tối ưu sâu về hiệu suất.
    \item Dự án tận dụng thư viện cộng đồng.
\end{itemize}

% FreeRTOS
\subsection{FreeRTOS}

\subsubsection{Giới thiệu tổng quan về FreeRTOS}
FreeRTOS (Free Real-Time Operating System) là một hệ điều hành thời gian thực nhẹ, mã nguồn mở, được thiết kế đặc biệt cho hệ thống nhúng. ESP-IDF tích hợp sẵn FreeRTOS như một phần lõi, và tất cả các ứng dụng chạy trên ESP32 đều hoạt động theo mô hình đa nhiệm của FreeRTOS.\\
FreeRTOS cung cấp khả năng chạy đồng thời nhiều tác vụ (task), hỗ trợ ưu tiên, đồng bộ hóa bằng semaphore, mutex và queue, rất cần thiết trong ứng dụng giao diện người dùng, nơi cần xử lý song song cảm ứng, WiFi, và logic nền.

\subsubsection{Vai trò của FreeRTOS trong hệ thống giao diện sử dụng LVGL}
LVGL là thư viện GUI cần được cập nhật định kỳ bằng cách gọi hàm \texttt{lv\_timer\_handler()} (trước đây là \texttt{lv\_task\_handler()}). Do đó, việc sử dụng FreeRTOS giúp:
\begin{itemize}
    \item Chạy \texttt{lv\_timer\_handler()} trong task riêng biệt, tránh ảnh hưởng đến các logic khác như WiFi, MQTT.
    \item Quản lý đa màn hình phức tạp, mỗi màn hình hoặc nhóm widget có thể liên kết với một task riêng để xử lý logic nội bộ.
    \item Đồng bộ hóa dữ liệu đa nguồn, ví dụ cập nhật nhiệt độ từ sensor và hiển thị lên giao diện thông qua queue hoặc message buffer.
    \item Ưu tiên xử lý GUI để đảm bảo trải nghiệm người dùng mượt mà, không bị lag hay giật.
    \item Tối ưu hóa tài nguyên hệ thống, tránh tình trạng tràn stack hoặc memory leak.
\end{itemize}

\subsubsection{Cách tích hợp FreeRTOS với LVGL}

\begin{itemize}
    \item \texttt{lv\_timer\_handler()}: xử lý redraw GUI.
    \item \texttt{vTaskDelay()}: delay trong vòng lặp GUI.
    \item \texttt{xSemaphoreTake()}: đồng bộ touch ISR và GUI task.
    \item \texttt{xQueueSend()}, \texttt{xQueueReceive()}: truyền dữ liệu giữa các task.
\end{itemize}

Ví dụ:

\begin{verbatim}
void lvgl_task(void* param) {
    while (1) {
        lv_timer_handler(); // Xử lý GUI
        vTaskDelay(pdMS_TO_TICKS(5)); // Delay 5ms
    }
}
\end{verbatim}

\subsubsection{Ưu điểm của FreeRTOS}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|p{10cm}|}
  \hline
  \textbf{Ưu điểm} & \textbf{Mô tả chi tiết} \\
  \hline
  Đa nhiệm thực thụ & Cho phép xử lý song song WiFi, cảm biến, touch, GUI... mà không block nhau \\
  Quản lý ưu tiên & Có thể đặt task GUI với mức ưu tiên cao hơn để luôn đảm bảo trải nghiệm mượt \\
  Tối ưu tài nguyên & Có thể cấu hình kích thước stack phù hợp cho từng task, tránh lãng phí RAM \\
  Công cụ debug tốt & ESP-IDF có task monitor, log theo từng core, theo dõi task alive \\
  Cấu trúc phần mềm rõ ràng & Phân chia task theo chức năng giúp code dễ bảo trì, mở rộng \\
  \hline
  \end{tabular}
  \caption{Ưu điểm của FreeRTOS}
\end{table}

\subsubsection{Hạn chế và cách khắc phục}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|p{10cm}|}
  \hline
  \textbf{Hạn chế} & \textbf{Giải pháp} \\
  \hline
  Cần hiểu rõ lập trình đa nhiệm & Học kỹ về race condition, deadlock, semaphore, mutex \\
  Dễ bị tràn stack task & Dùng \texttt{uxTaskGetStackHighWaterMark()} để kiểm tra stack thực tế \\
  Có thể phức tạp với người mới & Bắt đầu từ 1-2 task, dần mở rộng; sử dụng wrapper hoặc layer trung gian để đơn giản hóa \\
  \hline
  \end{tabular}
  \caption{Hạn chế và cách khắc phục trong FreeRTOS}
\end{table}

\subsubsection{Tình huống sử dụng điển hình}

\begin{table}[H]
  \centering
  \begin{tabular}{|l|p{10cm}|}
  \hline
  \textbf{Kịch bản} & \textbf{Vai trò FreeRTOS} \\
  \hline
  Cập nhật GUI liên tục theo sensor & Dùng task riêng đọc sensor → gửi queue → GUI task hiển thị \\
  Giao tiếp song song WiFi và touch & WiFi chạy trong task riêng, GUI có thể phản hồi ngay cả khi WiFi mất kết nối \\
  Nhiều màn hình có hiệu ứng animation & GUI task xử lý hiệu ứng, logic chuyển trạng thái đặt trong các task phụ trợ \\
  \hline
  \end{tabular}
  \caption{Tình huống sử dụng điển hình của FreeRTOS}
\end{table}

\subsection{Thư viện đồ họa LVGL}
\tab LVGL (Light and Versatile Graphics Library) là một thư viện đồ họa mã nguồn mở, nhẹ nhàng và linh hoạt, được thiết kế đặc biệt cho các hệ thống nhúng với tài nguyên hạn chế. Thư viện này cung cấp tất cả các công cụ cần thiết để tạo ra giao diện người dùng đồ họa (GUI) hấp dẫn và chuyên nghiệp trên các vi điều khiển như ESP32, với hiệu suất tối ưu và yêu cầu bộ nhớ thấp.
\subsubsection{Tổng quan về LVGL}
\tab LVGL được phát triển từ năm 2016 bởi Gábor Kiss-Vámosi, ban đầu với tên gọi LittlevGL. Qua nhiều năm phát triển, LVGL đã trở thành một trong những thư viện GUI phổ biến nhất cho các hệ thống nhúng, với các phiên bản chính từ v5 đến v9 hiện nay. Mỗi phiên bản đều mang đến những cải tiến đáng kể về hiệu suất, tính năng và khả năng tương thích.\\
\tab LVGL có nhiều đặc điểm và ưu điểm nổi bật so với các thư viện đồ họa khác cho hệ thống nhúng. Thư viện này được thiết kế với kiến trúc module hóa, cho phép chỉ biên dịch các thành phần cần thiết, giảm thiểu kích thước mã nguồn. LVGL hỗ trợ đa nền tảng, có thể chạy trên hầu hết các vi điều khiển 16, 32 hoặc 64 bit, từ các chip đơn giản như STM32 đến các nền tảng mạnh mẽ hơn như ESP32 hoặc Raspberry Pi.\\
\tab Một trong những ưu điểm lớn nhất của LVGL là khả năng tạo ra giao diện người dùng hiện đại và hấp dẫn với yêu cầu tài nguyên tối thiểu. Thư viện có thể hoạt động với chỉ 64 KB flash và 16 KB RAM, mặc dù cấu hình được khuyến nghị là khoảng 180 KB flash và 48 KB RAM để sử dụng đầy đủ tính năng. LVGL cũng hỗ trợ hoạt động với chỉ một frame buffer, giảm thiểu yêu cầu bộ nhớ đồng thời vẫn duy trì hiệu ứng đồ họa mượt mà.\\
\tab Về yêu cầu hệ thống và tương thích, LVGL có thể hoạt động trên hầu hết các vi điều khiển với tốc độ xung nhịp từ 16 MHz trở lên, mặc dù khuyến nghị tối thiểu 32 MHz cho hiệu suất tốt. Thư viện hỗ trợ nhiều loại màn hình với độ sâu màu khác nhau, từ màn hình đơn sắc đến màn hình TFT màu 16 hoặc 24 bit. LVGL cũng tương thích với nhiều loại thiết bị đầu vào như màn hình cảm ứng, nút bấm, encoder, và bàn phím.
\subsubsection{Kiến trúc LVGL}
\tab LVGL được xây dựng với kiến trúc module hóa, bao gồm các thành phần cốt lõi và các module chức năng. Cấu trúc này cho phép tùy chỉnh và mở rộng linh hoạt, đồng thời duy trì hiệu suất tối ưu cho các hệ thống nhúng.\\
\tab Cấu trúc lõi của LVGL bao gồm các module cơ bản như hệ thống đối tượng, quản lý bộ nhớ, hệ thống sự kiện, và engine vẽ. Các module này tạo nền tảng cho toàn bộ thư viện và cung cấp các chức năng cơ bản như quản lý đối tượng, xử lý sự kiện, và render đồ họa. LVGL sử dụng kiến trúc hướng đối tượng mặc dù được viết bằng C, với các cấu trúc dữ liệu và hàm được tổ chức theo cách mô phỏng lập trình hướng đối tượng.\\
\tab Hệ thống đối tượng và thừa kế trong LVGL cho phép tạo ra các widget phức tạp từ các thành phần cơ bản. Mỗi đối tượng trong LVGL đều kế thừa từ lớp cơ sở \texttt{lv\_obj}, thừa hưởng các thuộc tính và phương thức của lớp cha, đồng thời có thể mở rộng với các chức năng riêng. Cơ chế thừa kế này giúp giảm thiểu mã lặp lại và tạo ra hệ thống widget nhất quán và dễ mở rộng.\\
\tab Cơ chế quản lý bộ nhớ trong LVGL được thiết kế đặc biệt cho các hệ thống nhúng với bộ nhớ hạn chế. LVGL sử dụng bộ cấp phát bộ nhớ động riêng, cho phép kiểm soát chặt chẽ việc sử dụng bộ nhớ và tránh phân mảnh. Thư viện cũng hỗ trợ các cơ chế tái sử dụng bộ nhớ và giải phóng tự động, giảm thiểu rò rỉ bộ nhớ và tối ưu hóa hiệu suất.\\
\tab Hệ thống sự kiện và callback trong LVGL cho phép xử lý tương tác người dùng một cách linh hoạt và hiệu quả. Mỗi đối tượng có thể đăng ký các hàm callback để phản hồi với các sự kiện như nhấn, kéo, hoặc thay đổi giá trị. Hệ thống sự kiện hỗ trợ lan truyền sự kiện qua cây đối tượng, cho phép xử lý sự kiện ở nhiều cấp độ khác nhau.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{Images/LGVL_intro_data_flow.png}
  \caption{Tổng quan về luồng dữ liệu của LVGL}
\end{figure}
\subsubsection{Các thành phần chính giao diện}
\tab LVGL cung cấp một bộ widget phong phú để xây dựng giao diện người dùng, từ các thành phần cơ bản đến các container phức tạp và hệ thống bố cục linh hoạt.\\
Hệ thống widget cơ bản của LVGL bao gồm các thành phần như Button (nút bấm), Label (nhãn), và Image (hình ảnh). Button cung cấp chức năng tương tác cơ bản, với hỗ trợ cho các trạng thái khác nhau như nhấn, thả, và vô hiệu hóa. Label cho phép hiển thị văn bản với nhiều tùy chọn về font, căn chỉnh, và cuộn. Image hỗ trợ nhiều định dạng hình ảnh, bao gồm cả hình ảnh nén và hình ảnh với kênh alpha.\\
\tab Ngoài các widget cơ bản, LVGL còn cung cấp các thành phần phức tạp hơn như Chart (biểu đồ), Table (bảng), Dropdown (danh sách thả xuống), và Keyboard (bàn phím ảo). Các widget này cho phép xây dựng giao diện người dùng phức tạp với ít mã nguồn hơn, đồng thời duy trì hiệu suất tốt trên các hệ thống nhúng.\\
\tab Hệ thống styles và themes trong LVGL cho phép tùy chỉnh giao diện một cách linh hoạt và nhất quán. Styles định nghĩa các thuộc tính như màu sắc, font, padding, và border cho các widget. LVGL sử dụng cơ chế CSS-like để áp dụng styles, cho phép kế thừa và ghi đè các thuộc tính. Themes là tập hợp các styles được định nghĩa sẵn, cung cấp giao diện nhất quán cho toàn bộ ứng dụng.\\
\tab Bố cục và container trong LVGL giúp tổ chức các widget một cách linh hoạt và phản ứng. LVGL hỗ trợ các hệ thống bố cục hiện đại như Flex (dựa trên CSS Flexbox) và Grid (dựa trên CSS Grid), cho phép tạo ra giao diện phản ứng tự động điều chỉnh theo kích thước màn hình. Các container như Panel, Tabview, và Window giúp tổ chức nội dung thành các phần logic và cung cấp các chức năng như cuộn và chuyển tab.\\
\tab Hiệu ứng đồ họa và animation trong LVGL mang lại trải nghiệm người dùng động và hấp dẫn. Thư viện hỗ trợ các hiệu ứng như fade, move, và scale, với khả năng tùy chỉnh thời gian, đường cong chuyển động, và callback. Animations có thể được áp dụng cho hầu hết các thuộc tính của widget, từ vị trí và kích thước đến màu sắc và độ trong suốt.
\section{Công nghệ hiển thị cho hệ thống nhúng}
\tab Công nghệ hiển thị đóng vai trò quan trọng trong việc phát triển giao diện người dùng cho các hệ thống nhúng như ESP32. Các loại màn hình khác nhau cung cấp nhiều tùy chọn về kích thước, độ phân giải, chất lượng hiển thị và phương thức giao tiếp, cho phép nhà phát triển lựa chọn giải pháp phù hợp nhất với yêu cầu của dự án.
\subsection{Màn hình LCD và TFT}
\tab Màn hình LCD (Liquid Crystal Display) và đặc biệt là công nghệ TFT (Thin Film Transistor) LCD đã trở thành lựa chọn phổ biến cho các ứng dụng nhúng nhờ khả năng hiển thị màu sắc sống động, độ phân giải cao và giá thành hợp lý.\\
\tab Nguyên lý hoạt động của màn hình LCD dựa trên việc điều khiển các tinh thể lỏng để thay đổi cách ánh sáng đi qua chúng. Mỗi điểm ảnh (pixel) trên màn hình LCD bao gồm các tinh thể lỏng được đặt giữa hai tấm phân cực. Khi áp dụng điện áp, các tinh thể lỏng xoay và thay đổi cách ánh sáng đi qua, tạo ra các mức độ sáng tối khác nhau. Trong màn hình TFT LCD, mỗi pixel được điều khiển bởi một hoặc nhiều transistor màng mỏng, cho phép điều khiển độc lập và cải thiện đáng kể chất lượng hiển thị so với LCD thông thường.\\
\tab Các loại màn hình phổ biến cho ESP32 bao gồm ILI9341 và ST7789. Màn hình ILI9341 thường có kích thước 2.8 inch với độ phân giải 240x320 pixel, trong khi ST7789 thường được sử dụng trong các màn hình có kích thước từ 1.3 đến 2.0 inch với độ phân giải tương tự. Cả hai loại controller này đều hỗ trợ giao tiếp SPI, cho phép kết nối dễ dàng với ESP32 và tiêu thụ ít chân GPIO.\\
\tab Các đặc tính kỹ thuật quan trọng của màn hình TFT LCD bao gồm độ phân giải, độ sâu màu, góc nhìn và tốc độ làm mới. Độ phân giải thông thường cho các màn hình nhỏ dao động từ 240x240 đến 480x320 pixel. Độ sâu màu thường là 16-bit (65,536 màu) hoặc 18-bit (262,144 màu). Các yếu tố như góc nhìn và độ sáng cũng đóng vai trò quan trọng đối với trải nghiệm người dùng.

\subsection{Màn hình OLED}
\tab Màn hình OLED (Organic Light Emitting Diode) là công nghệ hiển thị tiên tiến với nhiều ưu điểm so với LCD, đặc biệt phù hợp cho các ứng dụng nhúng yêu cầu tiết kiệm năng lượng và chất lượng hiển thị cao.\\
\tab Nguyên lý hoạt động của màn hình OLED dựa trên các diode phát quang hữu cơ có khả năng tự phát sáng khi có dòng điện đi qua. Mỗi pixel là một diode phát quang độc lập, không cần đèn nền. Điều này cho phép tỷ lệ tương phản cao, thời gian đáp ứng nhanh, góc nhìn rộng và tiêu thụ năng lượng thấp khi hiển thị nội dung tối.\\
\tab So với LCD/TFT, OLED có tỷ lệ tương phản và độ sống động màu sắc cao hơn, thời gian đáp ứng nhanh hơn (dưới 1ms), và tiêu thụ năng lượng thấp hơn. Tuy nhiên, OLED có tuổi thọ ngắn hơn, dễ bị hiện tượng burn-in và chi phí cao hơn.\\
\tab Trong hệ thống nhúng, OLED phù hợp cho thiết bị đeo, thiết bị y tế cầm tay và các thiết bị IoT chạy pin. Nó cũng là lựa chọn lý tưởng trong môi trường ánh sáng yếu.
\subsection{Giao tiếp với màn hình}
Giao tiếp giữa ESP32 và màn hình là yếu tố ảnh hưởng đến hiệu suất và độ phức tạp của hệ thống. Các giao thức phổ biến gồm SPI, I2C và giao tiếp song song.

\begin{itemize}
  \item \textbf{SPI (Serial Peripheral Interface):} phổ biến cho màn hình TFT và OLED. Giao thức này sử dụng các đường MOSI, MISO, SCK và CS, có tốc độ cao (lên đến 80MHz). ESP32 có thể dùng DMA để cải thiện hiệu suất truyền dữ liệu.
  
  \item \textbf{I2C (Inter-Integrated Circuit):} phù hợp với màn hình OLED nhỏ và controller cảm ứng. Chỉ sử dụng hai dây SDA và SCL, giúp tiết kiệm GPIO. Nhược điểm là tốc độ thấp hơn (100kHz đến 1MHz).
  
  \item \textbf{Giao tiếp song song (Parallel):} cung cấp băng thông cao nhất nhưng cần nhiều GPIO. Giao tiếp 8-bit hoặc 16-bit được hỗ trợ qua giao diện I8080/6800.
\end{itemize}

Về điều khiển cảm ứng, các controller như XPT2046 (cảm ứng điện trở) và FT6X36 (cảm ứng điện dung) sử dụng SPI hoặc I2C. Cảm ứng điện dung hỗ trợ multi-touch và có trải nghiệm tốt hơn, nhưng phức tạp và đắt hơn cảm ứng điện trở.

Việc lựa chọn công nghệ hiển thị và phương thức giao tiếp phù hợp là yếu tố then chốt để tạo ra giao diện người dùng hiệu quả trên nền tảng ESP32. Kết hợp với thư viện như LVGL sẽ nâng cao trải nghiệm người dùng.

\section{Phân tích các giải pháp GUI cho ESP32}
\tab Khi phát triển ứng dụng với giao diện đồ họa người dùng (GUI) cho ESP32, nhà phát triển có nhiều lựa chọn về thư viện đồ họa. Mỗi thư viện có những ưu điểm, nhược điểm và trường hợp sử dụng riêng. Việc phân tích và so sánh các giải pháp này giúp lựa chọn công cụ phù hợp nhất cho dự án cụ thể.
\subsection{Các thư viện đồ họa hiện có}
\tab Thị trường thư viện đồ họa cho ESP32 khá đa dạng, với nhiều lựa chọn từ các thư viện đơn giản, nhẹ nhàng đến các framework GUI toàn diện. Dưới đây là phân tích chi tiết về các thư viện phổ biến nhất.
\subsubsection{TFT\_eSPI (Bodmer)}
\tab TFT\_eSPI là một thư viện đồ họa mạnh mẽ và được tối ưu hóa cao cho ESP32 và các vi điều khiển khác, được phát triển bởi Bodmer. Thư viện này được thiết kế đặc biệt cho màn hình TFT sử dụng giao tiếp SPI.\\
\tab Ưu điểm chính của TFT\_eSPI bao gồm hiệu suất cao nhờ tối ưu hóa mã assembly và sử dụng DMA, hỗ trợ nhiều loại controller màn hình (ILI9341, ST7789, ILI9488, \ldots), và tích hợp tốt với hệ sinh thái Arduino. Thư viện cung cấp các hàm vẽ cơ bản như điểm, đường, hình chữ nhật, hình tròn, và văn bản, cùng với hỗ trợ hiển thị hình ảnh và sprite (đối tượng đồ họa có thể di chuyển).\\
\tab Tuy nhiên, TFT\_eSPI có một số hạn chế. Thư viện không cung cấp các widget GUI cao cấp như nút bấm, thanh trượt, hoặc menu, khiến việc xây dựng giao diện người dùng phức tạp trở nên khó khăn hơn. Cấu hình thư viện cũng khá phức tạp, đòi hỏi chỉnh sửa file \texttt{User\_Setup.h} để phù hợp với phần cứng cụ thể.\\
\tab TFT\_eSPI phù hợp nhất cho các ứng dụng yêu cầu hiệu suất cao, hiển thị đồ họa cơ bản, hoặc khi nhà phát triển muốn xây dựng GUI tùy chỉnh từ đầu.
\subsubsection{Adafruit GFX}
\tab Adafruit GFX là một thư viện đồ họa phổ biến và dễ sử dụng, được phát triển bởi Adafruit Industries. Thư viện này cung cấp một API nhất quán cho nhiều loại màn hình khác nhau, từ OLED đơn sắc đến TFT màu.\\
\tab Ưu điểm của Adafruit GFX bao gồm tính đơn giản và dễ học, hỗ trợ rộng rãi từ cộng đồng, và tương thích với nhiều loại màn hình thông qua các thư viện driver riêng (như \texttt{Adafruit\_ILI9341}, \texttt{Adafruit\_SSD1306}). Thư viện cung cấp các hàm vẽ cơ bản tương tự như TFT\_eSPI, cùng với hỗ trợ font và hiển thị bitmap.\\
\tab Tuy nhiên, Adafruit GFX không được tối ưu hóa cho hiệu suất cao như TFT\_eSPI, đặc biệt trên ESP32. Thư viện cũng thiếu các widget GUI và hệ thống quản lý sự kiện, đòi hỏi nhà phát triển phải xây dựng các thành phần này từ đầu.\\
\tab Adafruit GFX là lựa chọn tốt cho người mới bắt đầu, các dự án đơn giản, hoặc khi cần tương thích với nhiều loại màn hình khác nhau trong cùng một codebase.
\subsubsection{U8g2}
\tab U8g2 là một thư viện đồ họa monochrome (đơn sắc) được tối ưu hóa cho các màn hình OLED và LCD đơn sắc. Mặc dù chủ yếu tập trung vào hiển thị đơn sắc, U8g2 vẫn là một lựa chọn quan trọng trong hệ sinh thái ESP32.\\
\tab Ưu điểm của U8g2 bao gồm kích thước nhỏ gọn, tiêu thụ bộ nhớ thấp, và hỗ trợ rộng rãi cho các controller màn hình đơn sắc (SSD1306, SH1106, \ldots). Thư viện cung cấp nhiều font với kích thước khác nhau, hỗ trợ nhiều ngôn ngữ, và có cơ chế buffer kép để tránh hiện tượng nhấp nháy khi cập nhật màn hình.\\
\tab Hạn chế chính của U8g2 là chỉ hỗ trợ màn hình đơn sắc, không phù hợp cho các ứng dụng yêu cầu hiển thị màu. Thư viện cũng thiếu các widget GUI và hệ thống quản lý sự kiện như các thư viện khác.\\
\tab U8g2 là lựa chọn tuyệt vời cho các ứng dụng sử dụng màn hình OLED đơn sắc, đặc biệt khi tài nguyên hệ thống hạn chế hoặc khi tiêu thụ năng lượng là ưu tiên hàng đầu.
\subsubsection{LVGL}

LVGL (Light and Versatile Graphics Library) là một thư viện GUI toàn diện, cung cấp không chỉ các hàm vẽ cơ bản mà còn bao gồm hệ thống widget phong phú, quản lý sự kiện, và nhiều tính năng cao cấp khác.

Như đã phân tích chi tiết trong phần trước, LVGL có nhiều ưu điểm nổi bật so với các thư viện khác. Thư viện cung cấp bộ widget phong phú (nút bấm, thanh trượt, bảng, biểu đồ, \ldots), hệ thống styles và themes linh hoạt, và hỗ trợ animation. LVGL được thiết kế để hoạt động hiệu quả trên các hệ thống nhúng với tài nguyên hạn chế, yêu cầu chỉ 64\,KB flash và 16\,KB RAM cho các tính năng cơ bản.

LVGL cũng có khả năng mở rộng cao, cho phép nhà phát triển tạo ra các widget tùy chỉnh hoặc mở rộng các widget có sẵn. Thư viện hỗ trợ nhiều loại thiết bị đầu vào (cảm ứng, nút bấm, encoder) và có thể hoạt động với nhiều loại màn hình khác nhau thông qua hệ thống driver linh hoạt.

Tuy nhiên, LVGL có đường cong học tập dốc hơn so với các thư viện đơn giản như Adafruit GFX, và cấu hình ban đầu có thể phức tạp. Thư viện cũng yêu cầu nhiều tài nguyên hơn so với các giải pháp đơn giản hơn, mặc dù vẫn được tối ưu hóa cho hệ thống nhúng.

LVGL là lựa chọn lý tưởng cho các ứng dụng yêu cầu GUI phức tạp, chuyên nghiệp, với nhiều widget tương tác và hiệu ứng đồ họa.

\subsection{So sánh và lựa chọn thư viện phù hợp}

Khi lựa chọn thư viện đồ họa cho dự án ESP32, cần cân nhắc nhiều yếu tố khác nhau để đưa ra quyết định phù hợp nhất.

\subsubsection{Hiệu suất và tài nguyên}

Về hiệu suất render, TFT\_eSPI thường dẫn đầu nhờ tối ưu hóa assembly và sử dụng DMA, tiếp theo là LVGL với engine render được tối ưu hóa. Adafruit GFX và U8g2 có hiệu suất thấp hơn nhưng vẫn đủ cho nhiều ứng dụng.

Về tiêu thụ bộ nhớ, U8g2 là nhẹ nhất, tiếp theo là TFT\_eSPI và Adafruit GFX. LVGL yêu cầu nhiều bộ nhớ nhất, đặc biệt khi sử dụng nhiều widget và animation, nhưng vẫn được tối ưu hóa cho hệ thống nhúng.

\subsubsection{Tính năng và khả năng mở rộng}

LVGL dẫn đầu về tính năng với bộ widget phong phú, hệ thống styles, và animation. TFT\_eSPI cung cấp các tính năng đồ họa cơ bản mạnh mẽ nhưng thiếu widgets. Adafruit GFX và U8g2 tập trung vào các chức năng vẽ cơ bản.

Về khả năng mở rộng, LVGL có kiến trúc module hóa cho phép mở rộng dễ dàng. TFT\_eSPI cũng khá linh hoạt nhưng đòi hỏi nhiều công sức hơn để mở rộng. Adafruit GFX và U8g2 có khả năng mở rộng hạn chế hơn.

\subsubsection{Độ phức tạp và đường cong học tập}

Adafruit GFX có đường cong học tập thoải nhất, phù hợp cho người mới bắt đầu. U8g2 và TFT\_eSPI có độ phức tạp trung bình, trong khi LVGL có đường cong học tập dốc nhất do cung cấp nhiều tính năng và khái niệm phức tạp hơn.

\subsubsection{Hỗ trợ cộng đồng và tài liệu}

Tất cả bốn thư viện đều có cộng đồng người dùng lớn và tài liệu tốt. Adafruit GFX có lợi thế về hướng dẫn và ví dụ từ Adafruit. LVGL có tài liệu toàn diện nhất với hướng dẫn, ví dụ, và tài liệu tham khảo API đầy đủ. TFT\_eSPI và U8g2 cũng có tài liệu tốt và cộng đồng hỗ trợ tích cực.

\subsubsection{Trường hợp sử dụng phù hợp}
\begin{itemize}
    \item \textbf{TFT\_eSPI}: Phù hợp nhất cho các ứng dụng yêu cầu hiệu suất cao, hiển thị đồ họa cơ bản, hoặc khi tài nguyên hệ thống hạn chế nhưng vẫn cần hiển thị màu.
    \item \textbf{Adafruit GFX}: Lý tưởng cho người mới bắt đầu, các dự án đơn giản, hoặc khi cần tương thích với nhiều loại màn hình khác nhau.
    \item \textbf{U8g2}: Tốt nhất cho các ứng dụng sử dụng màn hình OLED đơn sắc, đặc biệt khi tiêu thụ năng lượng và bộ nhớ là ưu tiên.
    \item \textbf{LVGL}: Phù hợp nhất cho các ứng dụng yêu cầu GUI phức tạp, chuyên nghiệp, với nhiều widget tương tác và hiệu ứng đồ họa.
\end{itemize}
\subsection{Tại sao chọn LVGL cho dự án phát triển thư viện giao diện}
Sau khi phân tích các giải pháp GUI hiện có, LVGL nổi bật như một lựa chọn tối ưu cho việc phát triển thư viện giao diện cho ESP32 vì nhiều lý do.
\begin{itemize}
    \item \textbf{Tính năng phong phú}: LVGL cung cấp một bộ widget phong phú và hệ thống styles linh hoạt, cho phép tạo ra giao diện người dùng hấp dẫn và chuyên nghiệp mà không cần phát triển từ đầu. Điều này giúp tiết kiệm thời gian phát triển đáng kể và mang lại kết quả chất lượng cao hơn.
    \item \textbf{Hiệu suất tối ưu}: LVGL được tối ưu hóa cho các hệ thống nhúng như ESP32, cân bằng giữa tính năng phong phú và hiệu suất. Thư viện có thể hoạt động hiệu quả với tài nguyên hạn chế của ESP32, đồng thời vẫn cung cấp trải nghiệm người dùng mượt mà.
    \item \textbf{Khả năng mở rộng}: Kiến trúc module hóa của LVGL cho phép mở rộng và tùy chỉnh dễ dàng, lý tưởng cho việc phát triển thư viện giao diện tùy chỉnh. Nhà phát triển có thể xây dựng các widget mới hoặc mở rộng các widget có sẵn để đáp ứng nhu cầu cụ thể của dự án.
    \item \textbf{Hỗ trợ cộng đồng và tài liệu}: LVGL có cộng đồng người dùng lớn, tài liệu toàn diện, và được cập nhật thường xuyên. Điều này đảm bảo rằng thư viện giao diện được phát triển sẽ có nền tảng vững chắc và hỗ trợ lâu dài.
\end{itemize}
\tab Với những ưu điểm trên, LVGL là nền tảng lý tưởng để phát triển thư viện giao diện cho ESP32, cung cấp sự cân bằng tối ưu giữa tính năng, hiệu suất, và khả năng mở rộng.
\section{Công cụ hỗ trợ phát triển}
\subsection{PlatformIO}
\subsubsection{Giới thiệu tổng quan}
PlatformIO là một môi trường phát triển tích hợp (IDE) hiện đại và mở rộng cho các hệ thống nhúng, đặc biệt phù hợp với các vi điều khiển như ESP32. Được phát triển như một plugin cho Visual Studio Code (VSCode), PlatformIO cho phép quản lý dự án, thư viện, board, và build system một cách dễ dàng, hỗ trợ cả framework ESP-IDF lẫn Arduino.\\
Nó là công cụ lý tưởng cho những ai muốn phát triển giao diện với LVGL vì có thể:
\begin{itemize}
    \item Quản lý thư viện trực tiếp từ CLI hoặc GUI.
    \item Tự động cấu hình các flag build, include path, và linker script.
    \item Hỗ trợ debug, monitor serial, và upload chỉ với một cú click.
\end{itemize}
\begin{figure}[H]
  \centering
  \includegraphics[width=1\textwidth]{Images/PlatformIO.png}
  \caption{PlatformIO trong workflow phát triển LVGL}
\end{figure}
\subsubsection{Tính năng nổi bật}
\tab PlatformIO cung cấp nhiều tính năng nổi bật giúp tăng tốc quá trình phát triển và quản lý dự án. Dưới đây là một số tính năng chính:
\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|}
\hline
\textbf{Tính năng} & \textbf{Mô tả} \\
\hline
Đa framework & Hỗ trợ ESP-IDF, Arduino, Zephyr, mbed, RT-Thread... \\
\hline
Hỗ trợ đa board & PlatformIO hỗ trợ sẵn hơn 900 board, trong đó có toàn bộ dòng ESP32 (ESP32-WROOM, S2, S3...) \\
\hline
Tự động build \& flash & Không cần viết Makefile hay config phức tạp – chỉ cần \texttt{platformio run} và \texttt{upload} \\
\hline
Monitor serial tích hợp & Dễ dàng in log từ ESP32 để debug \\
\hline
Quản lý thư viện & Cài LVGL, touch driver, font renderer, JPEG decoder... từ CLI hoặc GUI \\
\hline
Tích hợp VSCode & Có intellisense, gợi ý mã, refactor code, phân tích lỗi cú pháp realtime \\
\hline
\end{tabularx}
\caption{Các tính năng nổi bật của PlatformIO}
\end{table}


\subsubsection{Lý do nên sử dụng PlatformIO cho phát triển giao diện LVGL}
\begin{itemize}
    \item Tăng tốc khởi tạo dự án: Có thể tạo dự án ESP32 chỉ với 1 dòng lệnh \texttt{pio project init}, giúp nhanh chóng bắt đầu coding mà không cần cấu hình thủ công.
    \item Dễ dàng tích hợp LVGL: PlatformIO cho phép thêm thư viện LVGL từ PlatformIO Registry, đảm bảo luôn có phiên bản mới nhất, dễ update.
    \item Tự động xử lý dependency: Không cần tải thư viện thủ công hoặc sửa include path trong \texttt{CMakeLists.txt} – PlatformIO tự động thực hiện việc đó.
    \item Hỗ trợ nhiều profile build: Dễ dàng build ở các mode như debug, release, hoặc custom.
    \item Cộng đồng đông đảo, tài liệu phong phú: Nhiều template và ví dụ ESP32 + LVGL sẵn có.
\end{itemize}

\subsubsection{Hạn chế và cách khắc phục}

\begin{table}[H]
\centering
\begin{tabularx}{\textwidth}{|>{\raggedright\arraybackslash}X|>{\raggedright\arraybackslash}X|}
\hline
\textbf{Hạn chế} & \textbf{Cách giải quyết} \\
\hline
Tốc độ build chậm hơn ESP-IDF gốc & Bật chế độ build incremental, tăng RAM cache, và tắt phần mềm diệt virus quét thư mục \texttt{.pio} \\
\hline
Debug bị hạn chế nếu không dùng board chính thức & Kết hợp OpenOCD để debug hoặc chuyển sang ESP-IDF nếu cần debug chuyên sâu \\
\hline
Không tối ưu mạnh về kích thước chương trình như ESP-IDF & Sử dụng \texttt{build\_flags} để tinh chỉnh cờ biên dịch hoặc tối ưu file linker script \\
\hline
\end{tabularx}
\caption{Một số hạn chế của PlatformIO và cách khắc phục}
\end{table}

\subsubsection{Vai trò PlatformIO trong workflow tổng thể}
\begin{tabular}{|c|c|}
\hline
\textbf{Giai đoạn} & \textbf{Vai trò PlatformIO} \\
\hline
Khởi tạo dự án & Tạo nhanh template ESP32, tự động cấu trúc thư mục \\
\hline
Tích hợp thư viện & Quản lý dễ dàng thư viện GUI như LVGL, driver touch \\
\hline
Build \& Flash & Tự động build, upload, và theo dõi log serial \\
\hline
Phát triển UI & Soạn mã GUI trong VSCode, tận dụng intellisense \& lỗi runtime \\
\hline
Tinh chỉnh hiệu suất & Sử dụng monitor heap/log, custom flag để tối ưu kích thước và tốc độ \\
\hline
\end{tabular}
\subsection{SquareLine Studio}

\subsubsection{Giới thiệu tổng quan}
SquareLine Studio là một công cụ phát triển giao diện người dùng (UI) dành cho các nền tảng nhúng như ESP32, ESP8266, và STM32. Được xây dựng với mục tiêu đơn giản hóa việc thiết kế giao diện, SquareLine Studio cung cấp một môi trường trực quan với tính năng kéo và thả (drag-and-drop), giúp người dùng dễ dàng tạo và tùy chỉnh giao diện mà không cần phải viết mã thủ công cho từng widget hay thành phần giao diện.\\

SquareLine Studio đặc biệt hữu ích khi kết hợp với LVGL, giúp tối ưu hóa quá trình phát triển và cải thiện hiệu quả công việc, đặc biệt khi phát triển giao diện cho các hệ thống nhúng như ESP32, nơi tài nguyên phần cứng bị hạn chế.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{Images/Squaline Studio.png}
  \caption{Squaline Studio giao diện thiết kế}
\end{figure}
\subsubsection{Các tính năng chính của SquareLine Studio}
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\textbf{Tính năng} & \textbf{Mô tả} \\
\hline
Kéo thả widget & Cho phép người dùng dễ dàng kéo và thả các widget (như buttons, labels, sliders...) vào giao diện mà không cần phải viết mã. \\
\hline
Chỉnh sửa style theo theme & Tùy chỉnh giao diện của các widget thông qua các theme và style có sẵn. \\
\hline
Tạo mã nguồn C/C++ đầy đủ & Tự động sinh mã nguồn C/C++ hoàn chỉnh từ thiết kế giao diện, dễ tích hợp vào ESP32 hoặc STM32. \\
\hline
Hỗ trợ cấu hình phần cứng & Cung cấp các lựa chọn cấu hình phần cứng (LCD, touch, SPI...). \\
\hline
Hỗ trợ LVGL & Làm việc trực tiếp với thư viện LVGL. \\
\hline
Preview trực tiếp & Xem trước giao diện trong quá trình thiết kế. \\
\hline
\end{tabular}
\caption{Các tính năng chính của SquareLine Studio}
\end{table}

\subsubsection{Quy trình phát triển giao diện với SquareLine Studio}
\begin{enumerate}
  \item \textbf{Tạo dự án mới:} Mở SquareLine Studio và chọn nền tảng phần cứng và màn hình sử dụng.\\
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/new-project.png}
    \caption{Tạo dự án mới trong SquareLine Studio}
  \end{figure}
  \item \textbf{Thiết kế giao diện:} Kéo thả các widget và tùy chỉnh thuộc tính giao diện.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/thiet-ke-giao-dien.png}
    \caption{Thiết kế giao diện trong SquareLine Studio}
  \end{figure}
  \item \textbf{Tùy chỉnh style:} Áp dụng các theme có sẵn hoặc tùy chỉnh theo yêu cầu.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/custom-style.png}
    \caption{Tùy chỉnh style trong SquareLine Studio}
  \end{figure}
  \item \textbf{Sinh mã nguồn:} Tự động sinh mã C/C++ cho toàn bộ giao diện và xử lý sự kiện.
  \begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Images/export-UI.png}
    \caption{Sinh mã nguồn trong SquareLine Studio}
  \end{figure}
  \item \textbf{Tích hợp với ESP32:} Chèn mã vào dự án ESP32, cấu hình qua \texttt{menuconfig}, biên dịch bằng \texttt{idf.py}.
  \item \textbf{Test và tối ưu hóa:} Kiểm thử trực tiếp hoặc trên phần cứng, điều chỉnh hiệu ứng và hiển thị.
\end{enumerate}

\subsubsection{Ưu điểm khi sử dụng SquareLine Studio}
\begin{table}[H]
\centering
\begin{tabular}{|p{4cm}|p{10cm}|}
\hline
\textbf{Ưu điểm} & \textbf{Mô tả} \\
\hline
Tiết kiệm thời gian & Thiết kế kéo thả giúp tiết kiệm thời gian và công sức. \\
\hline
Chắc chắn và chính xác & Mã nguồn sinh ra tối ưu và hoàn chỉnh. \\
\hline
Dễ dàng tái sử dụng & Thiết kế và mã có thể dùng lại cho các dự án khác. \\
\hline
Tích hợp tốt với LVGL & Hỗ trợ đầy đủ tính năng đồ họa của LVGL. \\
\hline
Hỗ trợ đa nền tảng & Chạy được trên Windows, macOS, và Linux. \\
\hline
\end{tabular}
\caption{Ưu điểm của SquareLine Studio}
\end{table}

\subsubsection{Hạn chế và biện pháp khắc phục}
\begin{table}[H]
\centering
\begin{tabular}{|p{5.5cm}|p{8.5cm}|}
\hline
\textbf{Hạn chế} & \textbf{Giải pháp} \\
\hline
Không hỗ trợ toàn bộ tính năng LVGL & Có thể cần chỉnh sửa mã thủ công cho tính năng nâng cao. \\
\hline
Giới hạn trong thiết kế phức tạp & Phải can thiệp mã để xử lý logic phức tạp hoặc tuỳ chỉnh sâu. \\
\hline
Khả năng tùy biến giao diện hạn chế & Viết mã tùy chỉnh cho các hiệu ứng và hành vi đặc biệt. \\
\hline
\end{tabular}
\caption{Hạn chế và cách khắc phục khi dùng SquareLine Studio}
\end{table}

\subsubsection{Ứng dụng thực tế với SquareLine Studio}
SquareLine Studio hữu ích trong các dự án giao diện người dùng cho ESP32 với LVGL. Các ứng dụng phổ biến bao gồm:
\begin{itemize}
  \item Thiết kế giao diện cho thiết bị điều khiển từ xa: điều khiển, giám sát trạng thái, hiển thị cảm biến.
  \item Giao diện người dùng cho hệ thống IoT: đồng hồ thông minh, nhà thông minh.
  \item Giao diện cảm ứng: hỗ trợ tương tác như chạm, vuốt, thay đổi cảnh.
\end{itemize}
